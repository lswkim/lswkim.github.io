---
title: "[FastAPI í•µì‹¬êµ¬ì„±ìš”ì†Œ 2] Pydantic ë°ì´í„° ê²€ì¦"
date: 2025-12-28 21:00:00 +0900
categories: [Tech, FastAPI]
tags: [python, fastapi, pydantic, validation, data-model]
mermaid: true
---

> **ğŸ“š FastAPI ì‹œë¦¬ì¦ˆ - Part 4. FastAPI í•µì‹¬ êµ¬ì„±ìš”ì†Œ**
>
> 1. [Starlette í”„ë ˆì„ì›Œí¬](/posts/starlette/)
> 2. Pydantic ë°ì´í„° ê²€ì¦ â† í˜„ì¬ ê¸€
> 3. [íƒ€ì… íŒíŠ¸ì™€ ëŸ°íƒ€ì„ ê²€ì¦](/posts/type-hints-runtime/)
> 4. [ì˜ì¡´ì„± ì£¼ì… (Dependency Injection)](/posts/dependency-injection/)
> 5. [ë¯¸ë“¤ì›¨ì–´ ë™ì‘ ë°©ì‹](/posts/middleware/)

---

# 2. Pydantic ë°ì´í„° ê²€ì¦

## ì™œ ì´ ê°œë…ì´ ì¤‘ìš”í•œê°€?

- FastAPIì˜ ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬ í•µì‹¬
- ìë™ ë°ì´í„° ê²€ì¦ ë° ì§ë ¬í™”
- íƒ€ì… íŒíŠ¸ ê¸°ë°˜ ëŸ°íƒ€ì„ ê²€ì¦

---

## Pydanticì´ë€?

### í•œ ì¤„ ì •ì˜

**íƒ€ì… íŒíŠ¸ë¥¼ ì‚¬ìš©í•œ ë°ì´í„° ê²€ì¦ ë° ì„¤ì • ê´€ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬**

### í•µì‹¬ ê¸°ëŠ¥

| ê¸°ëŠ¥ | ì„¤ëª… |
|:---:|:---:|
| ë°ì´í„° ê²€ì¦ | íƒ€ì…, ì œì•½ì¡°ê±´ ìë™ ê²€ì¦ |
| íƒ€ì… ë³€í™˜ | ë¬¸ìì—´ â†’ ì •ìˆ˜ ë“± ìë™ ë³€í™˜ |
| ì§ë ¬í™” | Python ê°ì²´ â†” JSON |
| ìŠ¤í‚¤ë§ˆ ìƒì„± | JSON Schema ìë™ ìƒì„± |

---

## BaseModel ê¸°ì´ˆ

### ê¸°ë³¸ ì‚¬ìš©ë²•

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool = True  # ê¸°ë³¸ê°’

# ìƒì„±
user = User(id=1, name="Kim", email="kim@example.com")
print(user.id)        # 1
print(user.name)      # Kim
print(user.is_active) # True (ê¸°ë³¸ê°’)

# ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
print(user.model_dump())
# {'id': 1, 'name': 'Kim', 'email': 'kim@example.com', 'is_active': True}

# JSONìœ¼ë¡œ ë³€í™˜
print(user.model_dump_json())
# '{"id":1,"name":"Kim","email":"kim@example.com","is_active":true}'

```

### ìë™ íƒ€ì… ë³€í™˜

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str

# ë¬¸ìì—´ "123"ì´ ìë™ìœ¼ë¡œ int 123ìœ¼ë¡œ ë³€í™˜
user = User(id="123", name="Kim")
print(user.id)       # 123 (int)
print(type(user.id)) # <class 'int'>

```

---

## ê²€ì¦ ë™ì‘

### ê²€ì¦ ì‹¤íŒ¨ ì‹œ

```python
from pydantic import BaseModel, ValidationError

class User(BaseModel):
    id: int
    name: str

try:
    user = User(id="not_a_number", name="Kim")
except ValidationError as e:
    print(e)

```

```
1 validation error for User
id
  Input should be a valid integer, unable to parse string as an integer

```

### ê²€ì¦ ì—ëŸ¬ ìƒì„¸

```python
try:
    user = User(id="abc", name=123)
except ValidationError as e:
    print(e.errors())

```

```python
[
    {
        'type': 'int_parsing',
        'loc': ('id',),
        'msg': 'Input should be a valid integer, unable to parse string as an integer',
        'input': 'abc',
    }
]

```

---

## íƒ€ì… ì¢…ë¥˜

### ê¸°ë³¸ íƒ€ì…

```python
from pydantic import BaseModel
from typing import Optional, List, Dict
from datetime import datetime

class Example(BaseModel):
    # ê¸°ë³¸ íƒ€ì…
    name: str
    age: int
    score: float
    is_active: bool

    # Optional (None í—ˆìš©)
    nickname: Optional[str] = None

    # ë¦¬ìŠ¤íŠ¸
    tags: List[str] = []

    # ë”•ì…”ë„ˆë¦¬
    metadata: Dict[str, str] = {}

    # ë‚ ì§œ/ì‹œê°„
    created_at: datetime

```

### ì¤‘ì²© ëª¨ë¸

```python
from pydantic import BaseModel
from typing import List

class Address(BaseModel):
    city: str
    street: str

class User(BaseModel):
    name: str
    address: Address              # ì¤‘ì²© ëª¨ë¸
    friends: List["User"] = []    # ìê¸° ì°¸ì¡°

# ì‚¬ìš©
user = User(
    name="Kim",
    address={"city": "Seoul", "street": "Gangnam"},  # dict â†’ Address ìë™ ë³€í™˜
)
print(user.address.city)  # Seoul

```

---

## Fieldë¥¼ í†µí•œ ìƒì„¸ ê²€ì¦

### ê¸°ë³¸ ì œì•½ì¡°ê±´

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(min_length=2, max_length=50)
    age: int = Field(ge=0, le=150)           # 0 <= age <= 150
    email: str = Field(pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    score: float = Field(gt=0, lt=100)       # 0 < score < 100

# ì œì•½ì¡°ê±´ ìœ„ë°˜ ì‹œ ValidationError

```

### Field ì˜µì…˜

| ì˜µì…˜ | ì„¤ëª… | ì˜ˆì‹œ |
|:---:|:---:|:---:|
| `default` | ê¸°ë³¸ê°’ | `Field(default=0)` |
| `min_length` | ìµœì†Œ ê¸¸ì´ (str) | `Field(min_length=1)` |
| `max_length` | ìµœëŒ€ ê¸¸ì´ (str) | `Field(max_length=100)` |
| `ge` | ì´ìƒ (>=) | `Field(ge=0)` |
| `gt` | ì´ˆê³¼ (>) | `Field(gt=0)` |
| `le` | ì´í•˜ (<=) | `Field(le=100)` |
| `lt` | ë¯¸ë§Œ (<) | `Field(lt=100)` |
| `pattern` | ì •ê·œì‹ | `Field(pattern=r'^\d+$')` |
| `description` | ì„¤ëª… (ë¬¸ì„œìš©) | `Field(description="ì‚¬ìš©ì ì´ë¦„")` |

---

## ì»¤ìŠ¤í…€ ê²€ì¦

### field_validator

```python
from pydantic import BaseModel, field_validator

class User(BaseModel):
    name: str
    email: str

    @field_validator('name')
    @classmethod
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('ì´ë¦„ì€ ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
        return v.strip()  # ì•ë’¤ ê³µë°± ì œê±° í›„ ë°˜í™˜

    @field_validator('email')
    @classmethod
    def email_must_contain_at(cls, v):
        if '@' not in v:
            raise ValueError('ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤')
        return v.lower()  # ì†Œë¬¸ìë¡œ ë³€í™˜

```

### model_validator (ì—¬ëŸ¬ í•„ë“œ ê²€ì¦)

```python
from pydantic import BaseModel, model_validator

class DateRange(BaseModel):
    start_date: str
    end_date: str

    @model_validator(mode='after')
    def check_dates(self):
        if self.start_date > self.end_date:
            raise ValueError('start_dateëŠ” end_dateë³´ë‹¤ ì´ì „ì´ì–´ì•¼ í•©ë‹ˆë‹¤')
        return self

```

---

## FastAPIì™€ í†µí•©

### ìš”ì²­ ë³¸ë¬¸ ê²€ì¦

```python
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class CreateUserRequest(BaseModel):
    name: str = Field(min_length=2, max_length=50)
    email: str
    age: int = Field(ge=0, le=150)

@app.post("/users")
async def create_user(user: CreateUserRequest):
    # userëŠ” ì´ë¯¸ ê²€ì¦ ì™„ë£Œëœ Pydantic ëª¨ë¸
    return {"id": 1, "name": user.name}

```

### ìš”ì²­ íë¦„

```mermaid
flowchart TB
    REQ["1. í´ë¼ì´ì–¸íŠ¸ ìš”ì²­<br/>POST /users<br/>{'name': 'Kim', 'email': 'kim@test.com', 'age': 25}"]
    PARSE["2. FastAPIê°€ JSON íŒŒì‹±"]
    MODEL["3. Pydantic ëª¨ë¸ ìƒì„± ì‹œë„<br/>user = CreateUserRequest(**body)"]

    subgraph Result["ê²€ì¦ ê²°ê³¼"]
        SUCCESS["4-A. ê²€ì¦ ì„±ê³µ<br/>â†’ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ í˜¸ì¶œ<br/>â†’ ì •ìƒ ì‘ë‹µ"]
        FAIL["4-B. ê²€ì¦ ì‹¤íŒ¨<br/>â†’ ValidationError ë°œìƒ<br/>â†’ 422 ì‘ë‹µ ìë™ ìƒì„±"]
    end

    REQ --> PARSE
    PARSE --> MODEL
    MODEL --> SUCCESS
    MODEL --> FAIL
```

### 422 ì—ëŸ¬ ì‘ë‹µ ì˜ˆì‹œ

```json
{
    "detail": [
        {
            "type": "string_too_short",
            "loc": ["body", "name"],
            "msg": "String should have at least 2 characters",
            "input": "K"
        }
    ]
}

```

---

## ì‘ë‹µ ëª¨ë¸

### response_model ì‚¬ìš©

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UserCreate(BaseModel):
    name: str
    email: str
    password: str  # ì…ë ¥ì—ëŠ” í¬í•¨

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    # password ì—†ìŒ (ì‘ë‹µì—ì„œ ì œì™¸)

@app.post("/users", response_model=UserResponse)
async def create_user(user: UserCreate):
    # DB ì €ì¥ ë¡œì§...
    return {
        "id": 1,
        "name": user.name,
        "email": user.email,
        "password": user.password  # ë°˜í™˜í•´ë„ response_modelì— ì˜í•´ í•„í„°ë§ë¨
    }

```

```
ì‘ë‹µ:
{
    "id": 1,
    "name": "Kim",
    "email": "kim@test.com"
    // passwordëŠ” ìë™ìœ¼ë¡œ ì œì™¸ë¨!
}

```

---

## ì§ë ¬í™” ì˜µì…˜

### model_dump ì˜µì…˜

```python
from pydantic import BaseModel
from typing import Optional

class User(BaseModel):
    id: int
    name: str
    email: Optional[str] = None
    password: str

user = User(id=1, name="Kim", password="secret")

# ê¸°ë³¸
user.model_dump()
# {'id': 1, 'name': 'Kim', 'email': None, 'password': 'secret'}

# None ê°’ ì œì™¸
user.model_dump(exclude_none=True)
# {'id': 1, 'name': 'Kim', 'password': 'secret'}

# íŠ¹ì • í•„ë“œ ì œì™¸
user.model_dump(exclude={'password'})
# {'id': 1, 'name': 'Kim', 'email': None}

# íŠ¹ì • í•„ë“œë§Œ í¬í•¨
user.model_dump(include={'id', 'name'})
# {'id': 1, 'name': 'Kim'}

```

### ë³„ì¹­ (Alias)

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    user_id: int = Field(alias='userId')
    user_name: str = Field(alias='userName')

    model_config = {
        'populate_by_name': True  # ë³„ì¹­ê³¼ í•„ë“œëª… ë‘˜ ë‹¤ í—ˆìš©
    }

# ë‘˜ ë‹¤ ê°€ëŠ¥
user1 = User(userId=1, userName="Kim")
user2 = User(user_id=1, user_name="Kim")

```

---

## ê³ ê¸‰ íƒ€ì…

### Literal (íŠ¹ì • ê°’ë§Œ í—ˆìš©)

```python
from pydantic import BaseModel
from typing import Literal

class Order(BaseModel):
    status: Literal['pending', 'completed', 'cancelled']

Order(status='pending')    # âœ…
Order(status='invalid')    # âŒ ValidationError

```

### Annotated (ë©”íƒ€ë°ì´í„° ì¶”ê°€)

```python
from pydantic import BaseModel
from typing import Annotated
from pydantic.functional_validators import AfterValidator

def check_positive(v: int) -> int:
    if v <= 0:
        raise ValueError('ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤')
    return v

PositiveInt = Annotated[int, AfterValidator(check_positive)]

class Product(BaseModel):
    price: PositiveInt
    quantity: PositiveInt

```

### Enum ì‚¬ìš©

```python
from pydantic import BaseModel
from enum import Enum

class Status(str, Enum):
    PENDING = 'pending'
    COMPLETED = 'completed'
    CANCELLED = 'cancelled'

class Order(BaseModel):
    id: int
    status: Status

order = Order(id=1, status='pending')  # ë¬¸ìì—´ë„ ìë™ ë³€í™˜
print(order.status)        # Status.PENDING
print(order.status.value)  # 'pending'

```

---

## model_config ì„¤ì •

### ì£¼ìš” ì„¤ì • ì˜µì…˜

```python
from pydantic import BaseModel

class User(BaseModel):
    model_config = {
        'str_strip_whitespace': True,    # ë¬¸ìì—´ ì•ë’¤ ê³µë°± ì œê±°
        'str_min_length': 1,             # ë¬¸ìì—´ ìµœì†Œ ê¸¸ì´
        'frozen': True,                  # ë¶ˆë³€ ê°ì²´ (ìˆ˜ì • ë¶ˆê°€)
        'extra': 'forbid',               # ì •ì˜ë˜ì§€ ì•Šì€ í•„ë“œ ê¸ˆì§€
        'populate_by_name': True,        # ë³„ì¹­ê³¼ í•„ë“œëª… ë‘˜ ë‹¤ í—ˆìš©
    }

    name: str
    email: str

```

### extra ì˜µì…˜

```python
from pydantic import BaseModel

class StrictUser(BaseModel):
    model_config = {'extra': 'forbid'}
    name: str

# ì •ì˜ë˜ì§€ ì•Šì€ í•„ë“œ ì „ë‹¬ ì‹œ ì—ëŸ¬
StrictUser(name="Kim", unknown="value")  # âŒ ValidationError

```

| extra ê°’ | ë™ì‘ |
|:---:|:---:|
| `'ignore'` | ì¶”ê°€ í•„ë“œ ë¬´ì‹œ (ê¸°ë³¸ê°’) |
| `'forbid'` | ì¶”ê°€ í•„ë“œ ìˆìœ¼ë©´ ì—ëŸ¬ |
| `'allow'` | ì¶”ê°€ í•„ë“œ í—ˆìš© (ì €ì¥ë¨) |

---

## ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

### Pydantic v2 ê°œì„ ì 

| í•­ëª© | v1 | v2 |
|:---:|:---:|:---:|
| ì½”ì–´ | Python | **Rust (pydantic-core)** |
| ì†ë„ | ê¸°ì¤€ | **5~50ë°° ë¹ ë¦„** |
| ë©”ëª¨ë¦¬ | ê¸°ì¤€ | **ë” ì ìŒ** |

### ê²€ì¦ ë¹„ìš©

```python
# ê²€ì¦ì€ ê°ì²´ ìƒì„± ì‹œ ë°œìƒ
user = User(name="Kim", email="kim@test.com")  # ì—¬ê¸°ì„œ ê²€ì¦

# ì´ë¯¸ ê²€ì¦ëœ ë°ì´í„°ëŠ” model_constructë¡œ ìŠ¤í‚µ ê°€ëŠ¥ (ì£¼ì˜í•´ì„œ ì‚¬ìš©)
user = User.model_construct(name="Kim", email="kim@test.com")  # ê²€ì¦ ì•ˆ í•¨

```

---

## í•µì‹¬ ì •ë¦¬

| ê°œë… | ì„¤ëª… |
|:---:|:---:|
| **BaseModel** | Pydanticì˜ ê¸°ë³¸ ëª¨ë¸ í´ë˜ìŠ¤ |
| **ìë™ ê²€ì¦** | íƒ€ì…, ì œì•½ì¡°ê±´ ìë™ ì²´í¬ |
| **ìë™ ë³€í™˜** | "123" â†’ 123 ë“± íƒ€ì… ë³€í™˜ |
| **Field** | ìƒì„¸ ì œì•½ì¡°ê±´ ì •ì˜ |
| **validator** | ì»¤ìŠ¤í…€ ê²€ì¦ ë¡œì§ |
| **ì§ë ¬í™”** | model_dump(), model_dump_json() |
| **ValidationError** | ê²€ì¦ ì‹¤íŒ¨ ì‹œ ë°œìƒ |

### FastAPI ì—°ë™ ìš”ì•½

```mermaid
flowchart LR
    REQ["ìš”ì²­"] --> PARSE["JSON íŒŒì‹±"]
    PARSE --> VALID["Pydantic ê²€ì¦"]
    VALID --> HANDLER["í•¸ë“¤ëŸ¬ ì‹¤í–‰"]
    VALID --> ERR["ì‹¤íŒ¨ ì‹œ 422 ì‘ë‹µ ìë™ ìƒì„±"]
```